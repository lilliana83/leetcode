1. target sum: store the sum
2. predict the winner: take the min of the score to be played next by you
3. 2 keys keyboard: To get n 'A' on the notepad, we need to construct n 'A' from a string with length is a divisor of n
let assum n is constructed by n = ((1 * a) * b) * c) * d) * ........
from here we notice one interesting thing any string with length n which n is a prime will always take exactly n steps to construct the string (because prime has no divisor there will be no shortcut to make n, copying 'A' would take one step so making n will take n steps) and as we already knew a number n is made by the multiplication of its prime factors so does not matter what divisor of n you choose to construct n 'A' the minimum number of steps will always be the sum of each prime factor times the number of it because a number always need to be constructed by it prime factors. and the order does not matter, let take a look at 21 for example, 7 and 3 are prime factors of 21 , 21 = 7^1 * 3^1 you could eithor make 21 by making 7 after 7 steps at first then take 3 steps more by copy paste 3 times or by making 3 after 3 steps at first then take 7 steps more by copy paste 7 times it will always lead to the same result is 10
let quickly go through a more complex example with 20, 20 = 2^2 * 5 you have three optimes, making 10 first then multiply by 2 or making 2 first then multiply 10 or making 5 first then multiply by 4, you could easily see the best ways are option 2 and 3 by group all the same prime togethor that will help mininize the number of steps in general and does not matter the order you choose it will lead to the same output with the minimum step.
In conclusion the general fomula for this problem is number of steps = sum(x * x' + y * y' + z * z' ...)
with x,y,z,... is prime factors of n and x',y',z' are the number of x,y,z,....
here is the sample elegant code with(O(n))
4.est time to buy and sell stock with transactional fee:
B[j] = max(R[j-1], S[j-1]) - prices[j] - fee;
            S[j] = max(B[j-1], N[j-1]) + prices[j] ;
            R[j] = max(R[j-1], S[j-1]);
            N[j] = max(N[j-1], B[j-1]);
B: buy
R: rest
N: not sell/hold
S: sell
5. longest palindromic subsequence: not substring but subsequrnce
